# 负载均衡
## 随机算法
有权重的随机
```java
public static String getServer(){
int totalweight =0;
for (Integer weight ServerIps.WEIGHT_LIST.values()){
	totalWeight += weight;
}

java.util.Random random = new java.util.Random();
int pos random.nextInt(totalWeight);

for (String ip ServerIps.WEIGHT_LIST.keySet()){
	Integer weight ServerIps.WEIGHT_LIST.get(ip);
	if (pos < weight){
		return ip;
	}
	pos -= weight;
}

return "";
}
```

## 轮询算法
### 基础轮询
```java
Integer pos = 0;
int totalweight = 0;
for (Integer weight : ServerIps.WEIGHT_LIST.values()){
	totalWeight += weight;
}

public static String getServer(){
	pos = pos % totalWeight;
	String ip = ServerIps.LIST.get(pos);
	pos++;
	
	return ip;
}
```

### 平滑加权轮询
![[Pasted image 20240426153953.png]]
```java
Integer[] currentWeight = new Integer[ServerIps.WEIGHT_LIST.size()];

public static String getServer(){
Integer maxValue = null;
Integer maxIndex = null;
for(int i = 0; i < ServerIps.WEIGHT_LIST.size(); i++){
	currentWeight[i] += ServerIps.WEIGHT_LIST.get(i);
	if(maxValue = null || maxValue < currentWeight[i]){
		maxValue = currentWeight[i];
		maxIndex = i;
	}
}

String ip = ServerIps.WEIGHT_LIST.get(maxIndex).ip;

currentWeight[maxIndex] -= totalWeight;

return ip;
}
```

## 一致性哈希 / 哈希环
只有哈希环如果一个节点崩了，可能大部分的请求打到一个节点上，可以创建多个虚拟节点，让节点分布更均匀。
设置虚拟节点
```java
TreeMap<Integer, String> virtualNodes = new TreeMap<>();
int VIRTUAL_NODES = 160;

static{
for(String ip : ServerIps.LIST){
	for(int i = 0; i < VIRTUAL_NODES; i++){
		int hash  = getHash(ip+"VN"+i);
		virtualNodes.put(hash, ip);
	}
}
}


public static int getHash(String clientIp){
// ...
return hash;
}

public static String getServer(String clientIp){
int hash = getHash(clientIp);
SortedMap<INteger, String> subMap = virtualNodes.tailMap(hash);

Integer nodeKey = subMap.firstKey();
if(nodeKey == null){
	nodeKey = virtualNodes.firstKey();
}

return virtualNodes.get(nodeKey);
}
```




# 分布式ID
## 自增ID
设置自增步长，
``` 
// 两台服务器步长为2
Server1 : 1, 3, 5, 7
Server2 : 2, 4, 6, 8
```

## 号段模式
预先为每个节点分配一段连续的ID号段，节点在生成ID时从自己的号段中取出一个ID，这样可以减少对中心化ID生成器的依赖

为了防止号段用完了但数据库挂了，导致不能分配ID，所以当一个节点的ID号段**快要**用完时，它会向号段分配器请求新的号段。

## 雪花算法
左移+或运算实现二进制拼接
1bit 不使用 （long的符号位
41bit 时间戳
10bit 机器id
12bit 序列号

一毫秒内，序列号用完了就自旋，等到下一个毫秒

# 分布式事务
微服务架构中，对多个服务的分布式数据库中，实现分布式事务
[[simpread-分布式事务，这一篇就够了  小米信息部技术团队]]


