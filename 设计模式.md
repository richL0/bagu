# 创建型模式
## 单例模式
- Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
- WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
- **创建**的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。（创建实例很耗时，不如只创建一个一直调用）

##### 饿汉式
加载的时候就new 对象
```java
class Singleton {
	private static Singleton instance = new Singleton();
	private static Singleton(){} // 私有构造
	public static Singleton getInstance(){
		return instance;
	}
}
```

##### 懒汉式
第一次调用的时候new 对象
**双重检查锁**，在锁里面再次检查`instance == null`是因为在进入同步块之前，有可能其他线程已经创建了实例。所以需要再次检查，确保不会重复创建实例。这是双重检查锁定模式的一部分，提高了性能，避免了每次获取实例时都进行同步。
```java
class Singleton {
	private static volatile Singleton instance = null; // volatile 防止重排序
	private static Singleton(){} // 私有构造
	public static Singleton getInstance(){
		if(instance == null){ // 提升效率  避免频繁加锁
			synchronized (Singleton.class){  // 双重检查锁
			// A线程先加锁后已经创建好了释放锁
			// B线程此时获得锁  进来避免再次创建
				if(instance == null)
					instance = new Singleton();
			}
		}
		return instance;
	}
}
```

### 反射 创建多个实例

```java
public class BreakSingleton{
    public static void main(String[] args) throw Exception{
        Class clazz = Class.forName("Singleton");
        Constructor c = clazz.getDeclaredConstructor(null);

        c.setAccessible(true);

        Singleton s1 = c.newInstance();
        Singleton s2 = c.newInstance();
        //通过反射，得到的两个不同对象
        System.out.println(s1);
        System.out.println(s2);
    }
}

// 避免以上漏洞
class Singleton{
    private static final Singleton singleton = new Singleton(); 
    
	private Singleton() {
	//在构造器中加个逻辑判断,多次调用抛出异常
		if(instance!= null){
			throw new RuntimeException()
		}
    }
}
```


## 工厂方法模式
定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

![](https://refactoringguru.cn/images/patterns/diagrams/factory-method/solution3-zh.png)

如图, 只关注运输这个行为, 不在乎用什么工具(对象), 对象是根据你的实际接口构造的

![](https://refactoringguru.cn/images/patterns/diagrams/factory-method/structure.png)



### 抽象工厂
工厂不生产, 让子工厂生产
![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure.png)


## 生成器模式
亦称： 建造者模式、Builder

一个类有很多需要初始化的变量

![](https://refactoringguru.cn/images/patterns/diagrams/builder/problem2.png)
通常情况下， 绝大部分的参数都没有使用
使用一系列buildXXX()方法
![](https://refactoringguru.cn/images/patterns/diagrams/builder/solution1.png)

## 原型模式
亦称： 克隆、Clone、Prototype
通过实现`clone()`函数  可以创建大量一模一样的对象 
不用new 的方式创建对象




# 结构型模式
## 外观模式
类内部的实现很复杂, 但是只给你暴露一个简单的接口

当你通过电话给商店下达订单时， 接线员就是该商店的所有服务和部门的外观。 接线员为你提供了一个同购物系统、 支付网关和各种送货服务进行互动的简单语音接口。

![](https://refactoringguru.cn/images/patterns/diagrams/facade/live-example-zh.png?id=2dd7a77c9f6b9569f79ba0260291d89d)
缺点: 外观可能和程序中所有类都耦合的[上帝对象]

## 适配器模式
亦称： 封装器模式、Wrapper、Adapter
![](https://refactoringguru.cn/images/patterns/content/adapter/adapter-zh.png)

## 装饰模式
亦称： 装饰者模式、装饰器模式、Wrapper、Decorator

奶茶
奶茶+珍珠
奶茶+珍珠+椰果
![](https://refactoringguru.cn/images/patterns/content/decorator/decorator.png)

## 代理模式
![](https://refactoringguru.cn/images/patterns/diagrams/proxy/solution-zh.png)

## 中介模式
![](https://refactoringguru.cn/images/patterns/diagrams/mediator/live-example.png)
飞行器驾驶员之间不会通过相互沟通来决定下一架降落的飞机。 所有沟通都通过控制塔台进行。
## 观察者模式
维护一个订阅的列表
![](https://refactoringguru.cn/images/patterns/diagrams/observer/solution1-zh.png)
## 责任链模式
- 降低耦合度：它将请求的发送者和接收者解耦。
- 增加扩展性：可以方便地增加新的处理类
- Cons
	- 请求可能不处理
	- 需要遍历整个链
	- 不易调试
![](https://refactoringguru.cn/images/patterns/content/chain-of-responsibility/chain-of-responsibility.png?id=56c10d0dc712546cc283cfb3fb463458)


# 行为模式
## 策略模式
**策略模式**是一种行为设计模式， 它能让*你定义一系列算法*， 并将每种算法分别放入独立的类中， 以使*算法的对象能够相互替换*。

## MVC 模式
MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。

- Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。
- View（视图） - 视图代表模型包含的数据的可视化。
- Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。
