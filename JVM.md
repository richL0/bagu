编译器： JAVA源代码 -> 字节码
Java VM：字节码 -> 机器码

![[Pasted image 20240303163830.png]]


#  类加载 / 对象创建
类加载器用来加载类文件  就是`.class`文件
加载器负责将*字节码文件加载到内存*中，主要会经历加载->连接->实例化这三个阶段
## 类加载流程、对象创建流程
![](https://pic1.zhimg.com/v2-3bad66929576d72eaf0187d45cef3740_r.jpg)
### 1. 加载
查找并加载类的字节流
1. 通过类的*全限定名*来获取其定义的二进制字节流
2. 将这个字节流所代表的*静态存储结构转化为**方法区的运行时数据**结构*。
3. 在Java*堆*中生成一个代表这个类的`java.lang.Class`对象，作为对方法区中这些数据的*访问入口*

加载完成后
	字节流(原本在虚拟器外部)就按照虚拟机所需的格式*存储在方法区*中
	在Java堆中也创建一个`java.lang.Class`类的对象，这样便*可通过该对象访问方法区中的这些数据*。

#### 特性
- 可以自***定义自己的类加载器***来完成加载  (可控性最强的阶段)
- 不是首次主动使用才加载   ***将被使用时就预先加载它***
- 预先加载的过程中遇到`.class`文件缺失或错误
	- 首次主动使用该类时才报告错误   LinkageError错误
	- 如果一直没有主动使用   就不报告错误
- 多种文件形式（本地、网络、`.jar` / `.zip` 文件、数据库、`.java` 动态编译为`.class

### 2. 链接
给静态变量赋初始值，符号引用替换成直接引用
#### 验证
确保Class文件的字节流中包含的信息*符合虚拟机要求*
#### 准备
为*静态变量*（static 变量）分配内存，并将其初始化为默认值，这些内存都将在*方法区*中分配
`final static`变量直接赋初值（指定的值）
不包括类实例变量，其在实例化时**和对象一起**分配在Java堆中
默认值是数据类型的默认的零值(0, false, null)，而不是代码中显式赋的值
#### 解析  (可选的)
把类中的*符号引用转换为直接引用*主要针对：类/接口  字段  方法  句柄  调用点
符号引用：编译时的引用，它以符号的形式表示被引用的目标，例如类名、方法名、字段名等，在字节码中保存
直接引用：是在虚拟机运行时才产生的，直接定位到目标对象的内存地址
### 3. 初始化
1. 为静态变量赋初值（指定的值）
2. 执行静态代码块
初始化步骤：
1. 类还未加载和连接，先加载并连接该类
2. 父类还未初始化，先初始化父类
3. 类中有初始化语句，系统依次执行初始化语句

### 4. 实例化 / 对象的创建
以上只是加载了一个类，而不是创建了实例，只有调用new 方法才会创建实例
实例的创建：
1. 分配实例内存
2. 实例初始化：为实例变量赋默认零值
3. 设置对象头[[并发与多线程(JUC)#mark-word]]
4. 执行`<init>`方法：为实例变量赋初值 and 执行构造方法
初始化实例（给实例变量赋值  执行初始化语句）
然后执行构造函数（然后检查父类，有则先调用父类的构造函数）

## 类加载机制

四种机制: 
- `全盘负责`，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式地使用其他类加载器
- `父类委托`，先让*父类加载器试图加载*该类，只有在父类加载器*无法加载时尝试从自己的类路径中加载*该类
- `缓存机制`，缓存机制将会保证***所有加载过的Class都会被缓存***，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。*这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效*
- `双亲委派机制`, 类加载器收到加载请求，*不会先自己尝试加载*，而是把请求***委托给父加载器***，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当*父加载器没找到*所需的类时，子加载器*才尝试自己加载*。

### 双亲委派机制
向上委派
	`AppClassLoader`加载一个class时  委派给父类加载器`ExtClassLoader`
	`ExtClassLoader`会委派给它的父类加载器`BootStrapClassLoader`
向下归还
	如果`BootStrapClassLoader`加载失败 -> 还给`ExtClassLoader`
	`ExtClassLoader`也失败  -> 还给`AppClassLoader`

优势
- 避免类的*重复加载*
	*防止内存出现* 多份*相同字节码*
- 防止*恶意代码*通过自定义类加载器加载和*替换核心的Java API类*
- 提供类加载的*隔离性*

## 加载器

类型: 
![[Pasted image 20240303161050.png]]
### 自定义加载器的作用
1. 加载非标准文件格式的类
	如网络传输的字节码
2. 实现类的动态加载
3. 字节码的修改和增强
	如AOP（面向切面编程）


# 内存管理

## JMM 内存模型

![](https://img2018.cnblogs.com/blog/1158841/201906/1158841-20190604203226483-484132713.png)

### 缓存一致协议 MESI
volatile 底层通过汇编lock指令实现

多个cpu从主存读取同一个数据到各自的Cache，当某个cpu修改了缓存数据，该数据会马上同步回主存，其它cpu通过总线嗅探机制，感知到数据变化从而将自己缓存里的数据失效
### 指令重排序
#### as-if-serial规则
不管怎么重排序，单线程程序的执行结果不能被改变。
及对于数据存在依赖关系的代码，不能进行重排序
```java
double pi  = 3.14;    //A
double r   = 1.0;     //B
double area = pi * r * r; //C
```
AB没有依赖关系可以重排序，AC、BC有依赖关系，不能重排序
#### Happens-Before规则
A happens-before B并不代表A一定先于B发生。只是保证如果有**共享内存**，A改变后B立即**可见**。共有8条规则：
1. 加锁 Happens-Before 解锁
2. `volatile`的写 Happens-Before 读
3. 线程`start()` Happens-Before 线程内部代码
3. 线程内部代码 Happens-Before 线程`join()`
4. 线程`interrupt()` Happens-Before 检测中断
5. 对象构造 Happens-Before 析构
6. 传递性
7. 程序顺序
#### 半初始化问题
对于[[设计模式#单例模式]] 懒汉式创建，通过双重检查锁实现
但是对象的创建出现了指令重排序，对象已经分配了内存，但是还没初始化数值，就已经分配的内存地址赋值给变量，另一个线程调用就会把没初始化完的对象取走，出现错误

### 内存屏障
禁止重排序的代码，称为内存屏障，底层通过汇编的`lock`指令实现

- Store：直接把缓存的数据刷新到内存中。
- Load：直接从主存读数据，刷新到缓存中。
java 规范定义的四种内存屏障类型：
1. LoadLoad  读后读，load1; LoadLoad; load2
2. StoreStore  写后写
3. LoadStore  读后写，load1; LoadStore; store1
4. StoreLoad  写后读

## 运行时数据区
运行期间需要使用到的内存区域
存放了字节码信息以及*程序执行过程的数据*，*垃圾收集器*也会针对运行时数据区进行对象回收的工作

![[Pasted image 20240303151207.png]]


- **线程私有(灰色部分)**：程序计数器、虚拟机栈、本地方法栈
- **线程共享(其他)**：堆、方法区（Java7的永久代或JDK1.8的元空间、代码缓存）
### JVM栈
保存方法的局部变量、部分结果，参与方法的调用和返回。 方法执行时入栈（进栈/压栈），执行结束出栈
- **不存在垃圾回收问题**
- 大小是动态或不变的
	1. 固定大小的栈可能导致**StackOverflowError**
	2. 动态大小的栈可能没有足够内存分配给栈导致 **OutOfMemoryError**
- 栈中的数据都是以**栈帧（Stack Frame）的格式存在**
- 栈帧维护方法执行过程的各种数据信息
- 函数`return`和`throw Exception` 都会`pop`
![[Pasted image 20240303170156.png]]
![[Pasted image 20240303170315.png]]
#### 动态链接
一个栈帧内部都包含一个指向*运行时常量池*中该栈帧所属*方法的引用*

```java
public class DynamicLinking {
    static abstract class Human {
       protected abstract void sayHello();
    }
    
    static class Man extends Human {
        @Override
        protected void sayHello() {
            System.out.println("男人");
        }
    }
    
    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("女人");
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
		man.sayHello();       // 打印 "女人"
    }
}
```
在运行期动态地*根据实际类型确定方法*执行版本(方法重写)

### PC寄存器
- **线程私有**
- 唯一一个在 JVM 规范中没有规定任何 `OutOfMemoryError`的区域

### 堆
存放对象实例和数据的大小可扩展的内存区域

> [!info] 堆栈区别
> **栈是运行时的单位，而堆是存储的单位**。
> 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。

![[Pasted image 20240303174632.png]]
年轻代和老年代的堆内存大小比例为1：2
java 8之前有永久代，8后改成元空间
#### 年轻代
- 新对象创建的地方(除了大对象)
- 三个部分(8:1:1)
	- 伊甸园(占用空间最大)
	- 两个幸存区
- 伊甸园空间不足时 -> 执行垃圾收集 (称为 **Minor GC**

执行Minor GC时
1. 将幸存区的所有对象移到另一个幸存区象
2. 伊甸园的对移到幸存区
3. 对象年龄 +1
4. 年龄到达阈值的对象被移动到老年代

两个幸存区保证了对象占用的空间是连续的  避免了碎片化的空间浪费
#### 老年代
-  在老年代被填满时 -> 执行**Major GC** 
- 需要时间更长
- 大对象直接放进老年区
	避免在两个幸存区间进行大量的拷贝

### 方法区 (元空间mataspace / 永久代PermSpace)
https://zhuanlan.zhihu.com/p/166190558
方法区是在虚拟机规范中定义的，不同的虚拟机的实现不同，在HotSpot 虚拟机中在
- jdk1.7 版本之前的方法区实现叫永久代（PermGen space）
- jdk1.8 之后叫做元空间（Metaspace）。



元空间并不在虚拟机中，而是使用本地内存
永久代(java8后) -> 元空间(java8后)
存储了：
1. 类的原始数据（类信息、常量、静态变量、即时编译器（JIT）编译后的代码缓存
2. 运行时常量池
3. 字符串常量





## 内存溢出和内存泄漏
内存溢出：简单地说内存溢出就是指**程序运行过程中==申请的内存大于系统能够提供的内存==，导致无法申请到足够的内存**，于是就发生了内存溢出 **(OOM)**。

内存泄漏：内存泄漏指程序运行过程中**分配内存给临时变量，==用完后没有被GC回收==，始终占用着内存**，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。

造成内存泄漏的情况:
主要原因: [[#四种引用类型]] -> [[#强引用]]
![[#强引用]]

1. 静态集合类
	1. HashMap引用的对象不会被释放  和应用的生命周期一致
2. 修改HashSet中的对象
	1. HashSet中, 通过计算对象的hash值保存唯一的对象
	2. 如果修改对象中的数据, 且这个数据是计算hash的字段
	3. 就没法通过remove()删除这个对象
	4. 导致Set一直有这个对象
3. IO/连接/监听器未释放
	1. 如数据库连接 需要显式的close()才会断开连接
	2. addXXXListener()监听事件 也需要关闭才行
4. 单例模式
	1. 与静态变量类似
	2. 如果单例对象有外部变量的引用, 这个外部对象就不会被正常回收
5. [[并发与多线程(JUC)#ThreadLocal|ThreadLocal]]
	1. ThreadMap的key虽然用了弱引用，在GC时回回收TreadLocal实例
	2. 但是值是强引用，ThreadLocal设置的对象还是不会回收

### 避免泄漏的方法
1. 尽早释放无用对象的引用。
2. 避免在循环中创建对象。
3. 使用字符串处理时避免使用String，应使用StringBuffer。
4. 尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。




# 垃圾回收 (GC)

## 怎么确定垃圾
### 引用计数法
每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收

> [!info] 循环引用
> 可能会出现A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互引用 计数器=1 永远无法被回收。
#### 循环引用处理方法
1. 编程时明确的释放对象  `b.a = null;`
2. 使用非强引用(如弱引用, 软引用, 虚引用)
3. 编程时避免循环引用
4. 默认的垃圾回收都不使用引用计数法
### 可达性分析法
从 GC Roots 开始搜索。当一个对象是没法从 GC Roots 搜索到，则证明此对象是不可用的，就判断是垃圾。


**可以成为GCRoot的对象**
1. 虚拟机栈中引用的对象 (栈帧中的局部变量区,也叫局部变量表)
2. 方法区中静态引用的对象 (使用static修饰的对象)  
3. 方法区常量引用的对象 (使用final修饰的对象)  
4. 本地方法栈中JNI(Native方法)引用的对象 (使用Native修饰的方法, 线程中用的多.)

凡是被常量、静态变量、全局变量、运行时方法中的变量直接引用的对象，原则上不能被GC释放。

### 堆的GC
![[#堆]]

## 四种引用类型
#### 强引用
- 强引用是使用最普遍的引用 `Object o = new Object();`
- 回收强引用对象：`o = null;`
- 内存不足也不回收 -> 直接OOM

#### 软引用
- *内存不足时调用GC*
- GC后内存仍不足，则回收软引用包裹的对象
- 主要用于缓存
#### 弱引用
- *不管内存是否足够*，只要GC，弱引用*都会回收*
- 用于 -> ThreadLocal、WeakHashMap
- 主要用于缓存
- 如果一个对象很少使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，就可以使用弱引用。
#### 虚引用
- 最弱的引用
- 作用是提供一个对象被回收的通知
- 虚引用的`get()`永远返回`null `(无法通过虚引用获取对象
- 虚引用必须与`ReferenceQueue`一起使用
- GC回收对象时，如果有虚引用，则在回收前把这个虚引用加入到与之关联的`ReferenceQueue`中

## Full GC
触发Full GC
1. **老年代**的**内存使用率**达到了一定阈值
2. `System.gc()`
####  System.gc()
- 手动**提醒虚拟机**进行垃圾回收
- 回不回收**由虚拟机决定**
- 异步回收

### 频繁Full GC
1. 大对象，太大了直接进入老年代
2. 内存泄漏（强引用的对象，如：ThreadLocal，数据库的connection
3. 频繁生成长生命周期的对象
4. BUG
5. JVM的参数，堆内存太小、新老代分配不合理

## 垃圾回收器
[B站 GC机制](https://www.bilibili.com/video/BV1Gv411W7Hb)
![[Pasted image 20240303193227.png]]

#### CMS
只回收老年代
1. 初始标记 (`STW`)
	1. 暂停虚拟机 -> STW : "Stop-The-World"  暂停应用程序的执行，也称为`停顿`
	2. 由根对象扫描所有的关联对象，并标记
2. 并发标记 (`耗时`)
	1. 恢复所有暂停线程
	2. 扫描已标记的对象
	3. 取得所有与已标记对象*关联的对象*
3. 并发预清理
	1. 査找所有在*并发标记*阶段新进入老年代的对象
4. 重新标记 (`STW`)
	1. 暂停虚拟机
	2. 对*并发标记*时*改变的引用和新创建的对象*进行标记
5. 并发清理 (`最耗时`)
	1. 恢复线程
	2. 清理所有未标记对象
	3. 将己回收对象的空间重新拼凑为一个整体
6. 并发重置
	1. 重置CMS收集器的数据结构
	2. 等待下一次垃圾回收

##### 优势
1. 并发收集
2. 低停顿
	1. 最耗时的*并发标记*和*并发清除过程*
	2. 不会Stall用户Thread

##### 劣势
1. 无法处理***浮动垃圾***
	1. 浮动垃圾 -> *并发清理*过程产生的垃圾
	2. 为保证用户线程  会留一部分额外内存  内存不足时则退化调用SerialOld收集器
2. 对CPU敏感
	1. 和用户线程并行
	2. CPU资源紧缺
3. CMS使用“标记-清理”算法会产生大量的空间碎片
	1. 大量的碎片使空间无法充分利用  导致提前`FullGC`
4. 新的JDK会逐渐移除CMS
	1. Java9 标记废弃
	2. Java14 删除CMS

#### G1
[G1](https://www.bilibili.com/video/BV1D741177rV?p=2) (Garbage-First)
将堆分成若干(默认2048个)等大的区域(Region)，Rigion size depends on heap size
new objects 放在 eden(E) regions
当E regions 达到一定数量触发，***Minor gc***（把E的标记-复制到 Survivor，年龄+1）
年龄超过15， 转移到 old region
当heap快满了，*并发*标记所有O regions
触发***mix collection*** 回收E S O (E -> S, S ->O)

| 优点                    | 劣势                        |
| --------------------- | ------------------------- |
| 不产生内存碎片               | 内存占用高(需要建立并维护跨Region引用的表) |
| 可指定最大停顿时间             |                           |
| 回收有优先级，先回收价值更大的region |                           |
##### Rigions
**Humongous**
用于存储大对象(大于Region一半的对象)
可以减少Major GC 的次数




# JVM调优
## 堆参数
- `-Xms` -> 堆最小值
- `-Xmx `-> 堆最大堆值。
	 - -Xms与-Xmx 的单位默认字节都是以k、m做单位的。
	- 通常这两个配置参数相等，避免每次空间不足，动态扩容带来的影响。
- `-Xmn` -> 新生代大小
- `-Xss` -> 每个线程池的堆栈大小。
- `-XX:NewRatio` -> 设置新生代与老年代比值
	- -XX:NewRatio=4 表示新生代与老年代所占比例为1:4 ，新生代占比整个堆的五分之一。
	- 如果设置了-Xmn的情况下，该参数是不需要在设置的。
- `-XX:PermSize` -> 设置持久代初始值，默认是物理内存的六十四分之一
- `-XX:MaxPermSize` -> 设置持久代最大值，默认是物理内存的四分之一
- `-XX:MaxTenuringThreshold` -> 新生代中对象存活次数，默认15。
	- 若对象在eden区，经历一次MinorGC后还活着，则被移动到Survior区，年龄加1。
	- 以后，对象每次经历MinorGC，年龄都加1。
	- 达到阈值，则移入老年代
- `-XX:SurvivorRatio` -> Eden区与Subrvivor区大小的比值，如果设置为8，
	- 两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个新生代的十分之一
- `-XX:+UseFastAccessorMethods` -> 原始类型快速优化
- `-XX:+AggressiveOpts` -> 编译速度加快
- `-XX:PretenureSizeThreshold` -> 对象超过多大值时直接在老年代中分配
### 经验
1. Xmn用于设置新生代的大小。
	- 过小会增加Minor GC频率，过大会减小老年代的大小。
	- 一般设为整个堆空间的1/4或1/3.
2. XX:SurvivorRatio用于设置survivor和eden大小比例；
3. XX:TargetSurvivorRatio表示Minor GC后，survivor空间占有量超过时，压缩入老年代。
	- 默认值为50%。
4. 为了性能考虑，一开始尽量将新生代对象留在新生代，避免新生的大对象直接进入老年代。
	- 因为新生对象大部分都是短期的，这就*造成了老年代的内存浪费*，并且*回收代价也高*
5. 当`Xms=Xmx`，可以使得堆相对稳定，避免不停震荡
6. 一般来说，MaxPermSize设为64MB可以满足绝大多数的应用了。
	- 若依然出现方法区溢出，则可以设为128MB。若128MB还不能满足需求，那么就应该考虑程序优化了，减少动态类的产生。

## 垃圾回收

针对不同回收算法进行调优

- 考虑的指标
	 1. 吞吐量 -> 后端任务吞吐量优先
	 2. 停顿时间 -> 前端任务停顿时间优先



# 执行引擎

把字节码指令解释/编译为对应平台上的本地机器指令
> 字节码 -> 机器码 /  高级语言 -> 机器语言

![[Pasted image 20240303151541.png]]

## JIT  即时编译器
- 解释器
	- 一条一条解释并执行
- JIT
	-  把热点代码优化并放到Cache中
	- 加快


1. **JIT 即时编译器**
   - 解释器
     - 逐条执行代码
   - JIT
     - 优化热点代码
     - 存储优化后的代码于缓存中
     - 提高执行速度

**补充说明**
- JIT: Just-In-Time编译器，主要用于在程序运行时将字节码编译成机器码以提高执行效率。
- 热点代码: 指在程序执行过程中频繁执行的部分，通常这部分代码的性能对整体性能影响较大。

| **内容** | **解释** | **补充说明** |
| --------- | ------- | ---------- |
| **即时编译器** | **JIT** | 实时编译技术 |
| 解释器 | 一条一条解释并执行 | 逐行解释执行代码，不进行优化 |
| JIT | 把热点代码优化并放到Cache中 | 对频繁执行的代码进行优化并缓存以加快执行速度 |

**补充说明**
- JIT（Just-In-Time Compilation）是一种编译技术，主要用于提高程序的执行效率。
- 热点代码指的是程序中经常被执行的部分。
- Cache是高速缓存，用于存储频繁访问的数据或指令以加快访问速度。
- 
|