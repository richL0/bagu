引入MQ消息中间件最直接的目的是：做系统解耦合流量控制，追其根源还是为了解决互联网系统的高可用和高性能问题
系统解耦
- 用MQ消息队列，可以隔离系统上下游环境变化带来的不稳定因素
- 带来一致性问题
流量控制
- 遇到秒杀等流量突增的场景，通过MQ还可以实现流量的“削峰填谷”的作用，可以根据下游的处理能力自动调节流量
- 带来消息积压问题


![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/mq/rabbitmq-rumen-0e8d83f8-fdf0-4755-9131-1f5c775ca010.jpg)
1）P 是 Producer，代表生产者，也就是消息的发送者，可以将消息发送到 X
2）X 是 Exchange（为啥不是 E，我也很好奇），代表交换机，可以接受生产者发送的消息，并根据路由将消息发送给指定的队列
3）Q 是 Queue，也就是队列，存放交换机发送来的消息
4）C 是 Consumer，代表消费者，也就是消息的接受者，从队列中获取消息

# 消息丢失
哪些环节会丢失?

- **生产者发送消息**到RabbitMQ服务器的过程中出现消息丢失。可能是`网络波动`未收到消息，又或者是`服务器宕机`。
- RabbitMQ服务器**消息持久化**出现消息丢失。消息发送到RabbitMQ之后，未能及时存储完成持久化，RabbitMQ服务器出现`宕机重启`，消息出现丢失。
- 消费者**拉取消息过程**以及拿到消息后出现消息丢失。消费者从RabbitMQ服务器获取到消息过程出现`网络波动`等问题可能出现消息丢失；消费者拿到消息后但是消费者`未能正常消费`，导致丢失，可能是消费者出现`处理异常又或者是消费者宕机`。


**RabbitMQ解决方案**
- **confirm确认机制**
	- 用于确保消息被服务器接收或投递到队列
	1. 生产者发送带确认机制的消息至消息队列服务器。
	2. 服务器接收到消息后，向生产者发送一个确认回执（ACK）。
	3. 如果生产者收到确认回执，认为消息已成功投递；如果未收到回执或收到错误回执，可以根据策略进行重试或处理失败情况。
	4. 消费者从队列中取出消息，并发送一个消费回执给服务器。
	5. 服务器在收到消费回执后，从队列中删除该消息。
- **持久化机制**
	- 将消息存储在磁盘上，防止服务器重启时消息丢失
	- 通过设置delivery_mode和durable属性设置持久化
	- 会影响性能  可以在需要确保消息不丢失的情况下使用
- **ACK事务机制**
	- 消息被正确消费后发送ACK
	- 避免消息丢失
	- 如果ACK没有被MQ接收,可能会重复消费
# RabbitMQ消息重复
Producer 重复推送同一个数据到MQ  (没有做等幂性导致)
MQ 在Consumer响应ack挂了  MQ以为Consumer没有消费
Consumer 在响应ack时挂了  MQ以为Consumer没有消费

> [!info] 解决方案
> - 使用唯一约束做等幂性
> - 使用CAS 乐观锁+版本号
> - 检查MQ有没有记录


# 消息堆积
- Consumer处理太慢
	- 增加Consumer的数量
	- 优化Consumer代码/增加资源
	- 消息预取限制  防止大量消息并发使处理变慢
- 队列太小
- 消费者故障
	- 一直没法处理的消息->使用死信队列