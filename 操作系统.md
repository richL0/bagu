# I/O
[[JAVA基础#IO/NIO]]
[请描述 select、poll、epoll 这三种IO多路复用技术的执行原理](https://www.bilibili.com/video/BV1gN411e7gd)
[I/O 多路复用：select/poll/epoll](https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8)

## 同步非阻塞
```c
while (1){
	setNonblocking(listen_fd):
	accept_fd =  accept(listen_fd, addr, addrlen):
	if (accept_fd >0){// 如果这个socket没有数据就去轮询下一个fd
		fd_list.add(fd)
	}
}
```
优点: 不会阻塞 
缺点: 需要不断进行系统调用(accept 通过访问内核态查看有没有数据)

## 同步阻塞IO
```c
while(1){
	accept_fd = accept(listen_fd, addr, addrLen);
	read(accept_fd, buf, nbyte);
	logicHandle(buf);
}
```
单线程

如果设置*多线程*处理  如果有100个socket连接  创建100个线程  但是很多socket没有就绪
不断切换线程会影响性能


### I/O 多路复用
I/O多路复用是同步的I/O可以阻塞也可以不阻塞，通过设置timeout时间决定是否阻塞^[https://github.com/CyC2018/CS-Notes/issues/194#issuecomment-381395776]

#### select
执行流程：
1. 用户对关注的事件(读/写事件)生成对应的fdset（是一个bitmap），fdset置1说明关注该事件
2. 系统调用，将fdset传入内核，并传入一个，记录
3. 内核态轮询的扫描fdset，检查就绪事件，如果就绪了就将fdset置1，否则置0
4. 内核检查到就绪或超时则返回fdset给用户
5. 用户再次遍历fdset，检查哪些就绪了

优点: 
- 避免了大量系统调用
缺点: 
- 单线程监听的FD存在数量限制  bitmap 的长度限制为1024
- 状态切换: 每次调用还要把FD从**用户态拷贝到内核态**  
- 不知道哪个socket是就绪的, 通过轮询查询 复杂度 $O(n)$
- 入参的fdset每次调用都需要重置(内核直接在fdset上修改)

#### poll
是对select的优化，通过一个pollfd结构体的数组传入要监听的文件描述符
执行流程：
1. 用户初始化一个pollfd结构体的数组，记录要监控的fd和事件
2. 用户系统调用poll函数，传入pollfd数组到内核态，用户进程加入等待队列
3. 内核态轮询pollfd数组，检查是否就绪，就绪或超时则唤醒等待进程
4. 事件就绪则将已就绪的fd返回用户

优化了
1. 单线程FD数量没有1024的限制, 结构体数组代替bitmap
2. 入参的关注fd数组不需要每次重置
依然有的问题:
1. 每次调用还要把FD从**用户态拷贝到内核态**
2. 不知道哪个socket是就绪的，通过轮询查询 复杂度 $O(n)$

#### epoll
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll.png)
处理流程
1. epoll_create()系统调用，在内核创建一个epoll对象，存了红黑树、等待队列、就绪链表、事件集合
2. epoll_ctl()注册socket/fd和相关事件到内核中的epoll对象中，并为每个socket/fd设置回调函数
3. 用户调用epoll_wait()，阻塞等待期待的事件发生，如果有事件发生（事件在就绪链表中），不阻塞直接返回；否则：将当前进程阻塞挂起，加入等待队列
4. 触发事件后，执行回调函数，将socket/fd的事件加到就绪链表中，并唤醒等待队列中的进程
5. 内核把就绪队列的数据写回用户空间，epoll_wait()返回

特点
1. epoll通过***红黑树*来跟踪进程所有待检测的文件描述字**,  把需要监控的 socket 通过 `epoll_ctl()` 函数加入内核中的红黑树里; 由于整个socket集合都是存在内核中的,  所以每次检查只需要传入一个待检测的socket  避免了大量的数据拷贝和内存分配
2. 通过事件驱动, 其实现为,  内核里**维护了一个链表来记录就绪事件**, 即 ***就绪事件列表*** 当socket触发事件，通过回调函数就可以把这个socket加到就绪list中; 当用户调用 `epoll_wait()` 函数时, 只会返回有事件发生的文件数,  不需要轮询整个socket集合

#### 触发机制
##### 边缘触发（ET）
只有缓存区数据变化了才会触发事件。
这要求「一次性把数据读取&写入完」，否则会导致数据长期无法读取/写入。
如果没读完，剩下的数据只有下次再写入才会触发时才能读取。

##### 水平触发（LT）(默认
只要有数据就一直触发，会一直到没数据

## PageCache
存在内核态内存中的*页缓存*
![](https://ask.qcloudimg.com/http-save/yehe-7686797/8ae90ab58080dd66cae807542f8ef4f7.png)

是文件的逻辑地址组成的，用于
1. 防止频繁的读写磁盘
2. 提到频繁数据的访问速度

## Buffer
内存缓冲区：用于调节I/O设备和CPU间的速度不一致性，防止频繁访问磁盘
由操作系统控制什么时候刷入磁盘



## 面试题
### epoll为什么比select/poll快
1. 只有注册FD信息的时候才会把数据从用户态copy到内核态
2. 获取已就绪事件只拷贝已就绪的事件, 而不是拷贝所有的事件回用户态
3. 通过回调机制把文件描述符加入到就绪队列, 而不需要轮询

### 为什么使用红黑树, 而不是hash/B+Tree
hash 可能存在碰撞和内存的浪费, 创建的hash数组有很大一块是空的
B+树一个节点多个索引, 主要用在数据库的磁盘索引, 减少磁盘io访问次数

### epoll一定比select快吗?为啥还有人用poll
未必一定快,  如果并发很少的话整体的用户-内核拷贝时间不一定长



# Linux 信号
用于进程间通信、处理异常等情况的一种机制，操作系统向进程发送的异步通知
分为标准信号(值为1-31)和实时信号(值为32-64)
## 执行流程
### 信号的发送和接收
命令行通过`kill [-signal] PID`发送
`int kill(pid, int sig);`函数给其他进程发信号
编程通过`raise();`来向当前进程发送信号
通过 `pthread_kill` 给线程发信号


**接收**
1. `signal` 函数注册信号处理函数
2. `sigaction`函数用于设置和检索信号处理器
使用sigaction函数之前，应该先定义一个信号处理函数并将其注册
signal函数在某些情况下可能会出现问题，建议使用sigaction函数来注册信号处理函数

3. `sigwait` 函数可以用于阻塞等待一个或多个信号，并在信号到达时唤醒
4. `pause` 函数可以用于阻塞进程，直到接收到一个信号为止。

### 信号的处理机制
linux 是基于异步实现的信号传递，进程收到信号，内核会发送一个信号事件给进程，进程处理函数发送一个回调通知：
1. 内核检测到一个信号，向对应的进程发送一个信号事件
2. 进程收到信号，用注册的信号处理函数(一个自定义的函数)处理
3. 否则采用默认的处理方式
4. 信号处理完成后恢复执行原来的代码
5. 信号处理过程中收到同一个信号，则内核会把信号放入挂起信号队列中，等待进程执行完再触发信号处理
由于信号处理是异步的，可能会有线程安全问题，陷入死锁，可以通过使用可重入的函数避免

### 信号屏蔽机制
可以用于信号的排队，保证了信号不会丢失，信号队列是内核维护的

进程收到信号，内核会检测信号是否被屏蔽，如果屏蔽了就把信号放入挂起队列，等待进程解除屏蔽后再触发信号处理
通过`sigprocmask()`函数实现
在修改信号屏蔽字（一个屏蔽的信号的集合），需要保证操作的原子性



## 应用场景
1. 进程间通信
2. 异常处理：处理执行过程中的错误、非法操作、内存溢出等问题，避免程序崩毁
3. 系统调试：可以使用信号来实现*断点*调试（SIGTRAP信号）、输出*调试信息*（当前状态、变量值、堆栈等）、*检测*是否死循环or卡死等程序状态、记录运行时间or调用次数等性能分析

### 异常处理
#### 程序异常
空指针访问、内存溢出等，系统会发送 SIGSEGV 或 SIGABRT 信号，进程可以捕获信号，保存程序状态，而不是直接杀死进程。
#### 资源不足处理
内存不足、文件打开数达到最大限制等
系统发送相应信号，进程通过处理函数来释放资源、减少内存使用、关闭文件等，以避免系统崩溃。

## 并发问题
要注意可重入性问题、 并发问题、可靠性问题、
> [!info] 可重入性
> 指当信号处理函数被中断时，可以安全地再次调用该函数，而不会引起死锁或其他问题。

> [!info] 可靠性
> 保证进程能收到内核发送的信号，要注意检查信号是否真正接收及处理

可以用*信号屏蔽*（信号队列）实现信号的顺序性和唯一性


### 命令
# 进程间通信
目的是数据交换、资源共享、进程同步、消息传递
本质就是两个进程可以访问同一个内存区域
四种通信方式：管道、System V IPC、POSIX IPC、套接字
![[Pasted image 20240507160432.png]]

### 管道
无名管道：半双工、字节流方式通信、用于父子进程或兄弟进程等亲缘进程的通信，依赖于文件描述符
命名管道：也称为FIFO文件，允许不相关的进程通过读取和写入相同的文件来进行通信，位于文件系统中，依赖于文件名，允许双向通信（但是多个进程可能会消息交织，通过多个FIFO文件可以避免）
半双工：不能两个进程同时读同时写，同时只能有一个读，一个写

### 无名管道
#### 实现原理
创建两个文件，一个是"写"文件，一个是"读"文件，因为fork会复制父进程的文件描述符，所以子进程和父进程都可以看到这两个文件

**半双工**：实现了读写文件不冲突
实现全双工则需要创建两个"写"文件，两个"读"文件，独立操作

**无亲缘关系**的进程因为不是fork出来的，没有复制另一个进程的文件表，所以不能访问对应的文件

### 命名管道 FIFO文件
通过OPEN一个文件的方式读写文件，实现通信
多个进程同时写会有数据异常，所以创建多个fifo实现多进程读写

## System V 消息队列
独立于进程的通信，不受进程的启动和结束的影响
允许多个进程同时写入和读取，实现并行处理
可以设置消息优先值

#### 实现原理
**基于IPC命名空间实现**
具有相同的IPC命名空间的进程可以*同时访问*相同的内存空间

### System V 信号量
用于协调多个进程的操作，实现同步或互斥
常用的有
- P操作（等待操作、减操作）用于申请资源，信号量大于0则-1，等于0则阻塞
- V操作（释放操作、加操作）用于事发后资源，信号量+1，然后唤醒等待的资源
#### 信号量的实现原理
信号量是消息队列的子对象，

### System V 内存映射
将文件系统中的文件通过`mmap()`函数映射到内存空间中，进程可以通过操作系统的方式，操作内存，减少了IO

`mmap`将文件缓冲区映射到进程的虚拟地址空间共享区，直接在共享区完成读写操作，多个进程共享一个内存空间



## POSIX 消息队列
**基于文件实现**的消息队列，
特点是：操作POSIX对象就像操作文件一样
创建的POSIX创建的消息队列保存在`\dev\mqueue\` 文件夹中

#### 实现原理
通过mqueue inode节点（一个红黑树的结构）实现
### POSIX 信号量
称为命名信号量，通过设置一个值，实现剩余资源的管理 
  

#### 实现原理
通过tmpfs 文件系统和 `mmap` 内存映射共同实现


# fork
fork创建了父进程的一个复制，会把父进程的所有资源都复制一份，然后继续运行`fork()`后的代码

fork() 有两个返回值，一个值给父进程，一个值返回给子进程
父进程返回子进程的PID
子进程返回0
创建失败返回-1

# 内核
[Bilibili](https://www.bilibili.com/video/BV1Hz421k7oB)
[JavaGuide](https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81)

### 用户态和内核态
https://blog.csdn.net/weixin_63566550/article/details/131039726

用户态：有较低的权限，可以直接读取用户程序的数据；特殊权限（读写磁盘，网络通信）需要发起[[#系统调用]]
内核态：有最高权限，可以访问计算机几乎任何资源，进行进程、内存、文件、设备、网络管理等。
设置用户态出于以下考虑：
1. 特权指令：避免用户程序运行特权指令（内存分配、IO处理等）
2. 内存安全：防止用户程序获取or修改其他进程的数据

#### 用户栈和内核栈
Linux 系统中每个进程都有两个栈，分别是**用户栈和内核栈**，内核态与用户态的切换最重要的步骤是**用户栈和内核栈的切换**。

用户态到内核态时，会把用户栈地址、栈顶指针以及用户态其他寄存器值一起压入内核栈中。
内核态到用户态时，弹出寄存器的值，并送入对应的寄存器，实现运行状态的恢复

#### 用户态到内核态的三种方式
1. 系统调用：主动进入内核态，如访问磁盘、输入输出、断点
2. 中断：设备完成请求后响应给OS，向CPU发送中断信号，CPU处理中断，保存用户程序的上下文并进入内核态
3. 异常：缺页异常等

中断和异常通过[[#中断向量表]]来找到响应的内核程序

#### 系统调用
![[Pasted image 20240519182255.png]]
1. 用户态发起系统调用：保存对应的系统调用号和参数到寄存器，CPU Trap到内核态
2. 执行内核逻辑：CPU跳转到中断处理程序，保存上下文（保存当前用户态的寄存器，代码段、数据段、参数、PC寄存器等）到内核数据结构中，从寄存器取出系统调用号，找到对应的函数，根据寄存器中的参数运行函数
3. 回到用户态：CPU运行完中断处理程序后，执行中断返回指令，从内核数据结构取出上下文，回到用户态

![[Pasted image 20240519183341.png]]




### 软中断
https://www.xiaolincoding.com/os/1_hardware/soft_interrupt.html
**硬中断**CPU被打断，直接处理硬件请求，主要负责耗时短的工作，特点是快速执行；
**软中断**由内核触发，主要是负责硬中断未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；

避免由于中断处理程序执行时间过长，而影响正常进程的调度，软中断用来异步处理中断

Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，可以通过查看 /proc/softirqs 来观察软中断的累计中断次数情况

# 进/线程调度

### TimeWheel 时间轮
延时任务一般用Timer或ScheduledThreadPoolExecutor线程池，原理都是用`DelayQueue`，其底层是最小堆，插入的时间复杂度为$O(\lg n)$，高并发时性能不够

Kafka和Netty中用时间轮优化
![](https://img2022.cnblogs.com/blog/863118/202202/863118-20220212212752878-949069466.png)
用一个任务的时间mod槽位数来计算任务的位置，并通过链表连接
但是如果9秒的任务和1s的任务在一个槽，但是9秒的先来，在前面，1s在后面，产生bug


#### 多级时间轮
![](https://img2022.cnblogs.com/blog/863118/202202/863118-20220212213546358-694857520.png)

通过多个不同粒度的时间轮，时->分->秒，当小时轮需要调度时（不足1小时）则调度到分轮，以此类推

