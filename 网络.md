# ISO

| 层   | 作用                          | 传输形式 | 部件                  | 协议                         |
| --- | --------------------------- | ---- | ------------------- | -------------------------- |
| 物理层 | 数据传输、信号传输                   | 比特   | 中继器 HUB             | IEEE 802.3 (以太网)           |
| 链路层 | *帧的封装与解封装*，错误检测与纠正          | 帧    | 网卡、网桥<br>以太网  无线LAN | ARP、RARP、PPP               |
| 网络层 | *路由选择、分组转发*                 | 分组   | 路由器                 | IP (IPv4, IPv6), ICMP      |
| 传输层 | 端到端*通信*，可靠数据传输              | 数据段  | 无具体部件               | TCP, UDP                   |
| 会话层 | 建立, 终止、*管理会话*               |      | 无具体部件               | SSL/TLS, RPC               |
| 表示层 | 数据转换、加密<br>解决不同系统之间*通信语法问题* |      | 无具体部件               | XDR, ASN.1                 |
| 应用层 | 提供网络服务给*应用程序*               |      | 无具体部件               | HTTP, FTP, SMTP, POP3, DNS |

![[Pasted image 20240309191623.png|600]]
![[Pasted image 20240309191732.jpg|600]]

![OSI7层结构|600](https://pic1.zhimg.com/v2-2d62ba265be486cb94ab531912aa3b9c_r.jpg)

## TCP/IP五层
应用层 -> 传输层 -> 网络层 -> 链路层 -> 物理层 (*没有表示和会话*层)

*网络层是IP/ICMP*协议、*传输层是TCP/UDP*协议、*应用层是SMTP、FTP、HTTP* 等。他们都属于 TCP/IP 协议。

![[Pasted image 20240309193017.png]]

发送时各个层间一点一点封装
接收时一点一点解封装
![[Pasted image 20240309193215.png]]

## 网络设备
### 交换机
交换机通过识别*数据头部的MAC地址*区分电脑
通过自学机制  把MAC地址和交换机的端口号添加到MAC地址表中  然后根据地址表转发
### 路由器
路由器维护一个路由表  根据网络地址进行转发


# HTTP
基于TCP 的请求响应模型  （每次请求对应一次响应），无状态，明文传输，不安全：窃听、篡改、伪装

## HTTP 1.0
[HTTP1.0、1.1、2.0协议的特性及区别](https://juejin.cn/post/6963931777962344455)
### HTTP1.0
无连接
无状态：cookie / session
缺点：短连接
### HTTP1.1
长连接：keep-alive，保持不断
管道化：并行发送页面的图片/css/js等文件
缓存：支持缓存，新的字段如cache-control，支持断点续传
缺点：管道化队头阻塞，先请求了html文件后请求css，但是css已经准备好了不能发送，要等html发送了才发css
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5583691fea2141b9aa62a8c9729b5a37~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

![[#HTTP2.0]]

![[#HTTP3.0]]


## HTTPS
- HTTPS = HTTP + SSL/TLS
- 使用混合加密 (对称加密和非对称加密)
	- 用*非对称*加密实现*对称加密的密钥*
	- 然后通过*对称*加密的密钥进行加密*通信*
	- 因为*非对称加密的成本高*  对称加密的成本低
- 先通过TCP三次握手建立HTTP连接  然后进行TLS握手
- HTTPS端口号443
- 需要申请数字证书
### TLS握手
**TLS1.3**前 四次握手
TLS1.3后 两次握手

![[Pasted image 20240309201549.png]]
![[Pasted image 20240309202047.jpg]]

#### 证书校验
证书由权威机构(CA)提供
其中包含服务器提供的公钥
#### 校验
公钥加密 -- 私钥解密
用公钥加密，就可以保证只有*持有私钥的人才能读取消息*，没有私钥的人不能解密。保证私密。
私钥加签 -- 公钥验签
用私钥加签，就可以保证只有持有私钥的人才能发出消息，否则无法通过*公钥验签*。保证*身份不可伪造*。

CA计算证书(包括服务器公钥 有效期等)的Hash -> 对Hash值用CA的私钥加签 生成签名-> 发给客户端
客户端用公钥解密签名 -> 和证书的Hash对比
- 不一致则校验不通过
- 一致
	- 则验证颁发者的证书
	- 一直校验到根证书  全部通过才算通过

#### 根证书和证书链
根证书内置在操作系统
![[证书链.webp]]

## HTTP2.0
二进制分帧：HTTP1.0 是文本编码，2.0是二进制编码，分的帧更小
多路复用：单个TCP连接可以交错的进行请求和响应（服务器响应的同时可以继续请求），而不是请求-响应-请求-响应
服务器推送：把可能需要的都一起发过去（可能造成DDoS攻击
头部压缩：通过对header编码，服务器和client有一个decode的表，进行解码
报头ID：解决了1.1队头阻塞问题
## HTTP3.0
1. 使用UDP传输
	1. 避免了HTTP2.0 TCP阻塞的问题
2. 新建QUIC协议 其整合了 
	1. TCP
	2. TLS
	3. 将TCP连接和TLS连接合并为两次握手
3. 加入了连接ID 防止网络连接变化时再次握手
## 请求方法
1. GET
2. POST
3. PUT
![[Pasted image 20240412005916.png]]

不同方法的区别
**GET** 参数体现在URL中，，会被浏览器缓存，一般用于获取数据
**POST** 参数不体现在URL中，不会被浏览器缓存，一般用于提交数据
**PUT** 一般用于更新数据

但是这是建议的方法，你可以不遵守


### 状态码
HTTP 状态码
1. 1XX: 请求已接受,  继续处理
2. 2XX: 成功接收并接受
	1. 200 OK 一切正常
	2. 204  No Content成 功  只是响应HEAD没有数据
	3. 206  Partial Content 成功 但是响应的body不是全部数据
3. 3XX: 重定向
	1. 301 Moved Permanently 永久重定向  说明请求的资源已经不存在了，需改用新的 URL 再次访问。
	3. 302 Found 临时重定向   请求的资源还在，但暂时需要用另一个 URL 来访问。
	4. 304 Not Modified  资源未修改，重定向已存在的*缓冲文件*，也称缓存重定向，用于缓存控制。
4. 4XX: 报文有误
	1. 「400 Bad Request」表示客户端*请求的报文有错误*，但只是个笼统的错误。
	2. 「403 Forbidden」表示*服务器禁止访问*资源，并不是客户端的请求出错。
	3. 「404 Not Found」表示请求的资源在服务器上*不存在或未找到*，所以无法提供给客户端。
5. 5XX: 服务器处理时发生错误 报文正确
	1. 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
	2. 「501 Not Implemented」表示客户端请求的*功能还不支持*，类似“即将开业，敬请期待”的意思。
	3. 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问*后端服务器发生了错误*。
	4. 「503 Service Unavailable」表示服务器当前很*忙*，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。



## 缓存
### 强制缓存
只要本地缓存没有过期就一直用缓存
强缓存是通过HTTP的响应头(Response Header)实现资源的缓存有效期
- **Cache-Control** 相对时间
- Expires  绝对时间
- 如果响应头两个都有  则Cache-Control优先级更高

### 协商缓存
只有没有命中强缓存才进行协商缓存
协商缓存命中后返回 `304` 状态码
![[缓存etag.webp]]


# TCP/UDP

## TCP

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。
![[format,png-20230309230534096.webp|500]]
TCP基于字节流，且不记录包的大小，可能产生[[#粘包问题]]
可以通过IP报文计算TCP包大小：
- TCP Data 的长度 = IP 总长度 - IP Header 长度 - TCP Header 长度

### TCP四元组
包括：
1. 源IP地址：发送数据的主机的IP地址。
2. 源端口号：发送数据的主机上的应用程序所使用的端口号。
3. 目的IP地址：接收数据的主机的IP地址。
4. 目的端口号：接收数据的主机上的应用程序所使用的端口号。

源*地址*和目的地址的字段（32 位）是在 *IP 头部*中，作用是通过 IP 协议发送报文给对方主机。
源*端口*和目的端口的字段（16 位）是在 *TCP 头部*中，作用是告诉 TCP 协议应该把报文发给哪个进程。

### 粘包问题
https://segmentfault.com/a/1190000039691657
TCP基于字节流，且不记录包的大小，如果接收端的buffer里面先后的两个TCP包的字节流排在一起，不好区分，从而无法解析

##### 解决方案
- 固定长度的消息，但灵活性不高
- 特殊字符作为边界，如HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界，但需要转义。
![](https://cdn.xiaolincoding.com//mysql/other/a49a6bb8cd38ae1738d9c00aec68b444.png)
- 自定义消息结构，如在data部分自定义一个加入一个表示data长度的值
- 使用Netty 框架，其内置了多种数据流编解码器


### 断网问题
如果TCP连接在收发期间断网、拔掉网线
如果有数据传输：
1. Server会触发超时重传，如果重试次数超过预设的值（默认是15次），就会把错误报给应用层，然后断开TCP
2. 如果Client上线了继续访问Server，因为断开连接Server发送RST报文（RST位为1的报文），Client收到后断开连接

如果断网期间没有数据传输
- 没有开启 keep-alive机制：则TCP连接一直开启
- 开启了 keep-alive：通过互相发送TCP保活探测报文确认，如果连续几次探测没有响应就报告TCP连接已断开


## UDP
无连接的，基于报文传输的的协议
![[format,png-20230309230439961.webp|500]]
## TCP UDP 区别
1. *连接*
2. *服务对象*
	1. TCP 一对一
	2. UDP 一对一/多对多
3. *可靠性*
	1. TCP 可靠
	2. UDP 一般不可靠
		- 但是可通过应用层的设计实现可靠传输
4. *拥塞控制、流量控制*
5. *首部开销*
6. *传输方式*
	1. TCP流式传输  保证数据有序
	2. 包式传输  可能丢包/乱序
7. *分片不同*
8. *应用场景*
	1. TCP
		1. HTTP
		2. FTP
	2. UDP
		1. DNS
		2. SNMP
		3. 视频/音频/广播通信

## 三次握手 & 四次挥手
### 三次握手
![[TCP三次握手.drawio.webp|500]]

|       | 客   | 户   | 端   |     | 服   | 务   | 器   |     |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- |
|       | 自己  |     | 对方  |     | 自己  |     | 对方  |     |
|       | 发送  | 接受  | 发送  | 接受  | 发送  | 接受  | 发送  | 接受  |
| 第一次握手 | ❌   | ❌   | ❌   | ❌   | ❌   | ✔️  | ✔️  | ❌   |
| 第二次握手 | ✔️  | ✔️  | ✔️  | ✔️  | ❌   | ✔️  | ✔️  | ❌   |
| 第三次握手 | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  | ✔️  |
### 四次挥手
![[format,png-20230309230614791.webp|400]]



## 超时重传 & 拥塞控制
发出包RTT(一个来回的时间)后还没有收到`ACK`则重传
**快重传**: 连续收到3个同样的ACK则重传

### 慢启动  快恢复  拥塞避免
![[Pasted image 20240309225314.png]]



# IP
## DNS
### DNS有哪些记录
1. A记录：域名 -> IP 的映射
2. Cname：用于将一个域名映射到另一个域名，实现域名的别名或重定向
3. MX记录：用于邮件路由(SMTP协议)的记录，

为了保证DNS的记录缓存是新的，记录会有一个TTL（存活时间），超时后删除这个记录，下次调用需要再次向更域名申请
##### A记录
A记录就是最基础的：域名 -> IP 的映射
一个域名可以对应多个IP
``` 
owner        ttl    A address
foo.bar.baz. 60  IN A 192,168.1.1 
foo.bar.baz. 60  IN A 192.168.1.2 
foo.bar.baz. 60  IN A 192.168.1.3
```
##### Cname
别名
`fx.movie.edu IN CNAME magic.movie.edu`
`fx.movie.edu` 指向 `magic.movie.edu`

但是有个问题：访问 `a.fx.movie.edu` **不会转移**到 `a.magic.movie.edu`
BIND 9提供了DNAME，可以实现内部节点的别名

CNAME也可以指向另一个CNAME，但是有可能产生死循环

CNAME 在 BIND 9之前可以指定到多个域名上，可以通过管理员自定义的方法轮询转发，但是在BIND 9不允许
```
fullmonty IN CNAME fullmonty1
fullmonty IN CNAME fullmonty2
fullmonty IN CNAME fullmonty3
```


##### MX记录
早先版本，MX记录了MD记录（邮件目的地）和MF记录（邮件中转器）。先检查MD，MD不可用才用MF，但是效果不好，因为要查询两次，一次MD，一次MF。
后面将MD和MF二合一，称为MX（mail exchanger，邮件交换器），MX主机要么发给收件人，要么转发给更接近目标的MX主机

MX记录了一个优先级参数，优先发给优先级高的主机，如果一样则随便发一个；失败则尝试同优先级未尝试的，或较低优先级的。
为了防止路由**环路**，转发前会屏蔽优先级大于当前MX主机的记录



如果没有MX记录，但有A记录，一些中间件也会尝试向A记录的地址发。


### DNS的迭代和递归查询
递归查询：主机问上一级DNS server，上一级server再问上上级server
迭代查询：主机问上一级DNS server，上一级server发送上上级server给主机，主机再去访问上上级server
查询IP不是直接去DNS
1. 先去浏览器缓存查
2. 本地hosts文件中查
3. 递归查 Local DNS 
	1. Local DNS 先看本地缓存有没有这个域名
	3. 没有就迭代查根域名 -> 顶级域名


### 域名解析
客户端和本地DNS通过**递归**请求
本地DNS和根域名服务器通过**迭代**请求

解析顺序
1. 本地hosts文件
2. 发送DNS请求到本地DNS服务器
3. 本地DNS服务器请求上一级DNS
4. 一直到根DNS
5. 再到对应的顶级域名服务器

![[33.webp]]



 


### 负载均衡
BIND 4中，可以设置多个CNAME，多个A记录，轮询的实现负载均衡
BIND 9不可以设置多个CNAME，但仍然可以用多个A记录，实现负载均衡

- 轮询
- 可以通过修改配置文件对主机排序
- 可以通过计算RTT（round trip time，往返时间）排序


## CDN
https://www.zhihu.com/question/36514327/answer/1604554133

内容分发网络，让用户能够更快速的得到请求的数据，通过就近访问数据
![](https://img2020.cnblogs.com/blog/1789212/202007/1789212-20200707102440243-1989738666.png)

CDN 服务本身并不具备 DNS 解析功能，而是通过DNS的负载均衡实现的
在ping服务器IP时，因为走的是DNS，而DNS存的是CDN的IP，所以ping出来的不一定是真实IP


# 网络通信
## Socket
TCP socket 过程
![|300](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/tcp_socket.png)
服务端（S）
- 先调用socket()函数，创建一个TCP socket
- 再调用bind()，为这个socket绑定IP和Port
- 再调用listen()，监听socket，以接受进入的连接请求
- 进入监听后，调用accept()，阻塞地从内核获取客户端连接
- 成功建立连接后双方都可以通过 read() 和 write() 读写
客户端（C）
- 调用socket()函数，创建一个TCP socket
- 调用connect()，开始三次握手，成功连接后则通过 read() 和 write() 读写

在TCP连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：*半连接队列*：还没有完成三次握手的socket队列，和*全连接队列*：已经完成三次握手的socket队列

## Reactor模式
是一种基于事件驱动的，非阻塞同步网络模式，将就绪事件派发给对应服务处理程序的事件设计模式，主要用于处理大量短时连接或需要高效I/O处理的场景
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Reactor/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png)
包括三个组件：
1. Reactor：监听和分发事件
2. Acceptor：处理连接
3. Handler：处理请求，读写数据

分为：单reactor单线程，单reactor多线程，多reactor多线程3种
##### 单 Reactor 单线程 
1. Reactor 通过[[操作系统#I/O 多路复用|多路复用]]监控事件
2. 收到建立连接事件则用Acceptor accpet连接，并创建一个Handler处理该socket后续的事件

##### 单 Reactor 多线程 
Handler不处理事件，只收发数据，用线程池处理事件
![|700](https://img2020.cnblogs.com/blog/1477786/202007/1477786-20200720093157731-342860723.png)
1. Reactor 通过[[操作系统#I/O 多路复用|多路复用]]监控事件
2. 收到建立连接事件则用Acceptor accpet连接，并创建一个Handler响应对应的socket
3. Handler把数据发给子线程的Processor对象处理
4. Processor处理完把结果发给Handler，Handler返回给客户端

##### 多reactor多线程
多reactor中 设置了一个MainReactor和多个SubReactor
- 主线程中的 MainReactor 通过[[操作系统#I/O 多路复用|多路复用]]监控事件
- 收到建立连接事件则用Acceptor accpet连接，并将新socket分配给子线程
- 子线程的SubReactor继续监听socket，并创建Handler处理事件
- 新事件发生，则调用socket对应的Handler处理
- Handler进行read -> 处理业务 -> send

主Reactor的分配策略可以使用轮询，也可以配置其他[[分布式#负载均衡]]算法


Netty 和 Memcache 都采用了「多 Reactor 多线程」
[[Nginx]]采用了「多 Reactor *多进程*」，使用互斥锁防止[惊群现象](https://www.cnblogs.com/paul-617/p/15690810.html)



### Proactor
https://www.xiaolincoding.com/os/8_network_system/reactor.html#proactor
异步网络模式

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Reactor/Proactor.png)

可惜的是，在 Linux 下的异步 I/O 是不完善的， aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。

而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 IOCP，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。




## 零拷贝
将磁盘的文件通过网卡发送的流程
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png)
产生了2次系统调用，4次状态切换，4次拷贝
零拷贝通过直接讲缓存的数据给网卡的方式，避免了向用户态的拷贝
主要有两种实现方法：
1. mmap + write
2. sendfile
3. 网卡支持 SG-DMA

#### mmap + write
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png)
`mmap()`(系统调用)把文件读取到内核buffer，把这个buffer映射到用户buffer，这样用户就可以直接操作这个buffer，然后调用`write()`把缓冲区的数据写入socket buffer，

这样虽然不用写用户buffer，但是还是有2次系统调用，4次切换

#### sendfile
![[senfile-3次拷贝.webp]]
linux提供了一个系统调用函数`sendfile()`，可以代替read write的两次系统调用
只有一次系统调用，但是还是要3次拷贝

#### SG-DMA
真正的零拷贝技术：网卡如果支持SG-DMA技术，`sendfile()`可以直接把buffer的数据写到网卡中，不需要复制到socket buffer中
![[senfile-零拷贝.webp]]





# 网络安全
## 常见的Web攻击
### SQL注入
用户登录，输入用户名 lianggzone，密码`'' or '1'='1'` ，如果此时使用参数构造的方式，就会出现
```sql
select * from user where name = 'lianggzone' and password = '' or '1'='1'
```

**WEB端**
1. 有效性检验
2. 限制字符出输入长度
**服务端**
1. 不拼接SQL命令
2. 使用预编译的PrepareStatement
3. 再次有效性检验
4. 过滤特殊字符，如单引号、双引号等
### XSS攻击
[XSS网络攻击 - 原理](https://www.bilibili.com/video/BV1rg411v7B8)
> [!info] XSS 跨站点脚本攻击
> 通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。
> 具体地
> 1. 网站不校验用户输入的url，并且会把url中参数展示网页中，使黑客可以把恶意的代码注入url然后执行恶意脚本
> 2. 对于保存信息的网站（评论，博客等），黑客可以直接写包含一个恶意的脚本的评论，诱导用户点击即可

WEB端和server端都需要对输入的字符串限制长度，并对html进行转义处理如"<",">"等
防范XSS 的**核心是过滤处理**。

### CSRF
![[SpringSecurity#CSRF 跨站请求伪造]]

### 文件上传漏洞
用户上传一个可执行的脚本文件，通过脚本控制server

解决方案
1. 设置文件目录下的文件为不可执行
2. 结合文件MIME Type判断文件类型，并设置白名单
3. 重命名文件
4. 限制大小
5. 单独设置文件服务器

### DoS攻击
>[!info] DoS 攻击
>拒绝服务攻击，DDoS：分布式拒绝服务
>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认
>黑客请求建立TCP连接，server握手后黑客不ack，server不断发送或一直等待黑客的ack

没有彻底根治的办法，除非不使用TCP
预防：
1. 限制同时打开SYN半链接的数量
2. 缩短SYN半链接的Time Out时间
3. 关闭不必要的服务以及TCP 端口
#### SYN 泛洪 /Flood
Server维护一个半连接的队列（握手了一半，没完全建立连接的ip）
如果攻击者产生大量的syn请求，就会把半连接队列打满，没法响应正常访问

改善方案：
1. 降低SYN timeout，使得主机尽快释放半连接的占用
2. 异常连接检查过滤，标记某个异常IP（短时间大量的SYN请求）
3. 使用SYN cookie
##### SYN cookie
server第一次收到SYN不建立半连接队列，而是响应一个根据这个SYN包生成的cookie，下次client再把cookie传回来，server验证cookie，验证通过就直接建立TCP

虽然SYN cookie可以避免半连接队列打满，但是需要CPU验证Cookie，打满CPU




#### HTTP 泛洪
GET or POST泛洪
发送大量的GET or POST请求，占用Server的资源

#### 反射式洪水攻击
伪造发件人改为被攻击方：通过给其他主机伪造源地址（想攻击的Server的地址）的请求连接，这些主机就会对这个源地址进行响应，就会对攻击的Server造成泛洪攻击

#### rst攻击
发送rst数据进行连接断开请求，伪造请求的IP，断开某个正常IP的连接
# 面试题
## 输入URL 到页面展示
1. 进行DNS解析
	1. 检查浏览器缓存和本地host
	2. 访问本地DNS是否有配置/缓存
	3. 访问上级DNS
2. 建立TCP连接 三次握手
	5. 浏览器随机一个端口访问服务器的80端口
3. 发送http/https请求
	1. https 加入ssl 和 tls
	2. get 请求
4. 服务器返回数据
	1. 返回响应报文
	2. 响应头+html正文
5. 浏览器解析并渲染页面
6. 断开TCP连接 四次挥手
	1. 默认keep alive 只有关闭tab才断开
